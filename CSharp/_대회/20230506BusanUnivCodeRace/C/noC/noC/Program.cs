using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*
 1 초	512 MB
문제
못과 빈칸으로 이루어진 
$N\times M$ 크기의 추첨 판에서 경품 추첨을 진행하려고 한다. 추첨이 진행되는 과정은 다음과 같다.

추첨 판 임의의 위치에 한 칸 크기의 못들이 설치된다.
추첨 판의 가장 위 행 중 한 칸에서 공 하나가 떨어진다.
공은 아래쪽으로 직진하며 떨어지지만, 못을 만나면 같은 확률로 못 양옆 중 한 곳에 떨어진다.
공이 떨어지다 못을 만난 경우, 공의 옆이나 대각선 아래에 못이 있다면 그 방향으로 지나가지 못하고 걸린다. 이때는 공을 처음 위치로 되돌려 추첨을 다시 진행한다.
가장 아래 행에 도착한 공의 열 번호가 당첨 번호가 된다.
못이 박힌 후에 추첨 번호를 선택한다고 할 때, 당첨될 확률이 가장 높은 번호를 알아내 보자.

입력
첫째 줄에 추첨 판의 세로 길이 
$N$과 가로 길이 
$M$이 공백으로 구분되어 주어진다. 
$(3\leq N,M\leq 100)$ 

둘째 줄부터 
$N$개의 줄에 추첨 판을 나타내는 
$M$개의 정수가 공백으로 구분되어 주어진다. '0'은 빈 공간, '1'은 못, '2'는 처음 공의 위치를 의미한다.

처음 공의 위치는 반드시 가장 위 행에 하나 존재한다.

가장 왼쪽 열과 가장 오른쪽 열에는 못이 설치되지 않는다.

출력
가장 당첨될 확률이 높은 번호 
$C$를 출력한다. 그런 번호가 여러 개라면 그중 가장 작은 번호를 출력한다. 모든 번호가 당첨될 확률이 없다면 '-1'을 출력한다.

 
$(0\leq C\leq M-1)$ 
 */

namespace noC
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // 공의 위치를 좌표로 저장.
            // 못을 만날 때까지 공의 위치를 계속 아래로 보냄.
            // 못을 만날 때마다 그 상황을 저장. (포지션을 저장함.)
            // 조건에 따라 2개의 상황을 로딩함. (일단 왼쪽 먼저 보고 오른쪽 계산함, 해당 상황 스택에 저장하고.) (오른쪽? 왼쪽)
            // 이를 반복하다 바닥에 도착하면, 해당 바닥위치의 번호를 인댁스로 하는 배열에 접근하고 1 추가.
            // 0부터 끝까지 배열 돌다가 가장 높은 놈 골라서 출력,
            // 아마 트리를 이용하고 깊이 탐색을 해야 할 것으로 보임

            string[] size = Console.ReadLine().Split(' ');

            bool[,] map = new bool[int.Parse(size[0]), int.Parse(size[1])];
            List<(int x, int y)> position;

        }
    }
}
